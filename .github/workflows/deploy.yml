name: Deploy to AWS EC2 with PM2

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Configure SSH
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          
          # Create SSH config for ubuntu user
          cat > ~/.ssh/config << EOF
          Host $SSH_HOST
            User ubuntu
            StrictHostKeyChecking no
            UserKnownHostsFile ~/.ssh/known_hosts
            PreferredAuthentications publickey
            IdentitiesOnly yes
          EOF
          chmod 600 ~/.ssh/config

      - name: Deploy and restart PM2
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          GIT_REPO_URL: ${{ github.repositoryUrl }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          
          # Convert git:// URL to https:// if needed
          REPO_URL="$GIT_REPO_URL"
          if [[ "$REPO_URL" == git://* ]]; then
            REPO_URL=$(echo "$REPO_URL" | sed 's|git://|https://|')
          fi
          
          # Add token to URL if GITHUB_TOKEN is provided
          if [ -n "$GITHUB_TOKEN" ]; then
            REPO_URL=$(echo "$REPO_URL" | sed "s|https://|https://$GITHUB_TOKEN@|")
          fi
          
          echo "Starting deployment to ubuntu@$SSH_HOST:$DEPLOY_PATH"
          
          ssh $SSH_HOST "DEPLOY_PATH='$DEPLOY_PATH' REPO_URL='$REPO_URL' GITHUB_TOKEN='$GITHUB_TOKEN' bash -s" << 'ENDSSH'
            set -e
            
            # Create deployment directory if it doesn't exist
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "Creating deployment directory: $DEPLOY_PATH"
              mkdir -p "$DEPLOY_PATH"
            fi
            
            cd "$DEPLOY_PATH" || { echo "Error: Failed to change to directory: $DEPLOY_PATH"; exit 1; }
            
            # Initialize or update repository
            if [ ! -d ".git" ]; then
              echo "Initializing repository..."
              if [ "$(ls -A . 2>/dev/null)" ]; then
                echo "Warning: Directory is not empty. Removing existing contents..."
                rm -rf ./* ./.* 2>/dev/null || true
              fi
              
              # Clone repository with token if provided
              if [ -n "$GITHUB_TOKEN" ]; then
                git clone "$REPO_URL" . || {
                  echo "Git clone failed, trying with token authentication..."
                  REPO_URL_WITH_TOKEN=$(echo "$REPO_URL" | sed "s|https://|https://$GITHUB_TOKEN@|")
                  git clone "$REPO_URL_WITH_TOKEN" .
                }
              else
                git clone "$REPO_URL" .
              fi
            else
              # Update remote URL if needed
              CURRENT_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
              CLEAN_REPO_URL=$(echo "$REPO_URL" | sed 's|https://.*@||')
              
              if [ "$CURRENT_REMOTE" != "$CLEAN_REPO_URL" ] && [ "$CURRENT_REMOTE" != "$REPO_URL" ]; then
                echo "Updating git remote URL..."
                git remote set-url origin "$CLEAN_REPO_URL" 2>/dev/null || git remote add origin "$CLEAN_REPO_URL"
              fi
              
              echo "Pulling latest changes..."
              
              # Pull with token if needed
              if [ -n "$GITHUB_TOKEN" ]; then
                git pull origin main || {
                  echo "Git pull failed, trying with token authentication..."
                  git -c credential.helper='!f() { echo "username=$GITHUB_TOKEN"; echo "password=$GITHUB_TOKEN"; }; f' pull origin main || \
                  git pull https://$GITHUB_TOKEN@$(echo "$REPO_URL" | sed 's|https://||' | sed 's|.*@||') main
                }
              else
                git pull origin main
              fi
            fi
            
            # Install dependencies
            if [ -f "package.json" ]; then
              echo "Installing npm dependencies..."
              npm install
            else
              echo "No package.json found, skipping npm install"
            fi
            
            # Get PM2 process ID if process exists
            PM2_ID=""
            PM2_NAME=""
            
            if command -v pm2 &> /dev/null; then
              # Try to find existing PM2 process by name or ID
              PM2_LIST=$(pm2 jlist 2>/dev/null || echo "[]")
              
              if [ "$PM2_LIST" != "[]" ] && [ -n "$PM2_LIST" ]; then
                if command -v jq &> /dev/null; then
                  # Get the first online process ID
                  PM2_ID=$(echo "$PM2_LIST" | jq -r '.[] | select(.pm2_env.status == "online") | .pm_id' | head -n 1)
                  PM2_NAME=$(echo "$PM2_LIST" | jq -r '.[] | select(.pm2_env.status == "online") | .name' | head -n 1)
                else
                  # Fallback: get ID from pm2 list
                  PM2_ID=$(pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
                fi
              fi
            fi
            
            # Stop PM2 process if it exists
            if [ -n "$PM2_ID" ] && [ "$PM2_ID" != "null" ] && [ "$PM2_ID" != "" ]; then
              echo "Stopping PM2 process (ID: $PM2_ID)..."
              pm2 stop $PM2_ID || pm2 stop "$PM2_NAME" || pm2 stop all || true
            else
              echo "No existing PM2 process found, stopping all processes..."
              pm2 stop all || true
            fi
            
            # Start PM2 process
            echo "Starting PM2 process..."
            if [ -f "ecosystem.config.js" ]; then
              pm2 start ecosystem.config.js
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            elif [ -f "app.js" ]; then
              pm2 start app.js
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            else
              pm2 start npm -- start
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            fi
            
            # Wait for process to initialize
            sleep 2
            
            # Display PM2 status and process ID
            echo ""
            echo "PM2 Process Status:"
            pm2 status
            
            if [ -n "$NEW_PM2_ID" ] && [ "$NEW_PM2_ID" != "null" ] && [ "$NEW_PM2_ID" != "" ]; then
              echo ""
              echo "PM2 Process ID: $NEW_PM2_ID"
            fi
          ENDSSH
          
          echo "Deployment completed successfully"

      - name: Capture PM2 logs on failure
        if: failure()
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "Capturing PM2 logs due to deployment failure..."
          
          ssh $SSH_HOST "cd '$DEPLOY_PATH' && bash -s" << 'ENDSSH'
            echo "=== PM2 Status ==="
            pm2 status || echo "PM2 status command failed"
            echo ""
            
            echo "=== PM2 Process List ==="
            pm2 jlist || echo "PM2 jlist command failed"
            echo ""
            
            echo "=== PM2 Logs (Last 200 lines) ==="
            pm2 logs --lines 200 --nostream || echo "PM2 logs command failed"
            
            # Capture individual process logs if available
            PM2_LIST=$(pm2 jlist 2>/dev/null || echo "[]")
            if [ "$PM2_LIST" != "[]" ] && [ -n "$PM2_LIST" ]; then
              if command -v jq &> /dev/null; then
                for id in $(echo "$PM2_LIST" | jq -r '.[] | .pm_id' 2>/dev/null); do
                  echo ""
                  echo "=== Logs for PM2 process ID: $id ==="
                  pm2 logs $id --lines 100 --nostream || echo "Could not retrieve logs for process $id"
                done
              fi
            fi
          ENDSSH

