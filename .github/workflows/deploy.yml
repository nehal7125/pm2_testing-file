name: Deploy to AWS EC2 with PM2

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Extract and Setup Public Key
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Save private key temporarily to extract public key
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/temp_key
          chmod 600 ~/.ssh/temp_key
          
          # Extract public key from private key
          ssh-keygen -y -f ~/.ssh/temp_key > ~/.ssh/public_key.pub 2>/dev/null || {
            echo "Warning: Could not extract public key automatically"
            rm -f ~/.ssh/temp_key ~/.ssh/public_key.pub
            exit 0
          }
          
          PUBLIC_KEY=$(cat ~/.ssh/public_key.pub)
          echo "Extracted public key: ${PUBLIC_KEY:0:50}..."
          
          # Clean up temporary private key
          rm -f ~/.ssh/temp_key
          
          # Try to add public key to ubuntu's authorized_keys on server
          # First, try connecting as ubuntu (if key is already there)
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Try to add the key (this will work if we can connect via another method)
          # We'll try to connect and add it automatically
          echo "Attempting to setup public key on server..."
          
          # Save public key to a file for use in next steps
          echo "$PUBLIC_KEY" > ~/.ssh/public_key.pub
          echo "PUBLIC_KEY_FILE=~/.ssh/public_key.pub" >> $GITHUB_ENV

      - name: Configure SSH
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          
          # Create SSH config for ubuntu user
          cat > ~/.ssh/config << EOF
          Host $SSH_HOST
            User ubuntu
            StrictHostKeyChecking no
            UserKnownHostsFile ~/.ssh/known_hosts
            PreferredAuthentications publickey
            IdentitiesOnly yes
          EOF
          chmod 600 ~/.ssh/config
          
          # Verify SSH agent has the key loaded
          echo "SSH keys loaded in agent:"
          ssh-add -l || echo "Warning: No keys found in SSH agent"
          echo ""
          echo "SSH will connect as user: ubuntu"

      - name: Setup Public Key on Server
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          # Read public key from file
          PUBLIC_KEY=$(cat ~/.ssh/public_key.pub)
          
          # Try to add public key to ubuntu's authorized_keys automatically
          echo "Setting up public key on server..."
          
          # Try connecting and adding the key
          ssh $SSH_HOST "PUBLIC_KEY='$PUBLIC_KEY' bash -s" << 'ENDSSH' || {
            echo "Could not automatically setup key. Will try connection test..."
            exit 0
          }
            set -e
            # Create .ssh directory if it doesn't exist
            sudo mkdir -p /home/ubuntu/.ssh
            sudo chmod 700 /home/ubuntu/.ssh
            
            # Add public key if not already present
            if [ -f /home/ubuntu/.ssh/authorized_keys ]; then
              if ! grep -qF "$PUBLIC_KEY" /home/ubuntu/.ssh/authorized_keys 2>/dev/null; then
                echo "$PUBLIC_KEY" | sudo tee -a /home/ubuntu/.ssh/authorized_keys > /dev/null
                echo "Public key added to authorized_keys"
              else
                echo "Public key already exists in authorized_keys"
              fi
            else
              echo "$PUBLIC_KEY" | sudo tee /home/ubuntu/.ssh/authorized_keys > /dev/null
              echo "Created authorized_keys file with public key"
            fi
            
            # Set correct permissions
            sudo chmod 600 /home/ubuntu/.ssh/authorized_keys
            sudo chown ubuntu:ubuntu /home/ubuntu/.ssh/authorized_keys
            sudo chown ubuntu:ubuntu /home/ubuntu/.ssh
            
            echo "Public key setup completed successfully"
          ENDSSH

      - name: Test SSH Connection
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
        run: |
          echo "Testing SSH connection to ubuntu@$SSH_HOST..."
          if ssh $SSH_HOST "echo 'SSH connection successful!'; echo 'Logged in as: \$(whoami)'" 2>&1; then
            echo ""
            echo "✅ SSH connection test passed!"
          else
            echo ""
            echo "❌ SSH connection test failed!"
            echo ""
            echo "=========================================="
            echo "TROUBLESHOOTING:"
            echo "=========================================="
            echo "The SSH key setup failed. Please manually add the public key to your EC2 server:"
            echo ""
            echo "Public key to add:"
            cat ~/.ssh/public_key.pub
            echo ""
            echo "Run these commands on your EC2 server:"
            echo "  sudo mkdir -p /home/ubuntu/.ssh"
            echo "  sudo chmod 700 /home/ubuntu/.ssh"
            echo "  echo '$PUBLIC_KEY' | sudo tee -a /home/ubuntu/.ssh/authorized_keys"
            echo "  sudo chmod 600 /home/ubuntu/.ssh/authorized_keys"
            echo "  sudo chown ubuntu:ubuntu /home/ubuntu/.ssh/authorized_keys"
            echo ""
            exit 1
          fi

      - name: Deploy and restart PM2
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          GIT_REPO_URL: ${{ github.repositoryUrl }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          
          # Convert git:// URL to https:// if needed
          REPO_URL="$GIT_REPO_URL"
          if [[ "$REPO_URL" == git://* ]]; then
            REPO_URL=$(echo "$REPO_URL" | sed 's|git://|https://|')
          fi
          
          # Add token to URL if GITHUB_TOKEN is provided
          if [ -n "$GITHUB_TOKEN" ]; then
            REPO_URL=$(echo "$REPO_URL" | sed "s|https://|https://$GITHUB_TOKEN@|")
          fi
          
          echo "Starting deployment to ubuntu@$SSH_HOST:$DEPLOY_PATH"
          
          ssh $SSH_HOST "DEPLOY_PATH='$DEPLOY_PATH' REPO_URL='$REPO_URL' GITHUB_TOKEN='$GITHUB_TOKEN' bash -s" << 'ENDSSH'
            set -e
            
            # Create deployment directory if it doesn't exist
            if [ ! -d "$DEPLOY_PATH" ]; then
              echo "Creating deployment directory: $DEPLOY_PATH"
              mkdir -p "$DEPLOY_PATH"
            fi
            
            cd "$DEPLOY_PATH" || { echo "Error: Failed to change to directory: $DEPLOY_PATH"; exit 1; }
            
            # Initialize or update repository
            if [ ! -d ".git" ]; then
              echo "Initializing repository..."
              if [ "$(ls -A . 2>/dev/null)" ]; then
                echo "Warning: Directory is not empty. Removing existing contents..."
                rm -rf ./* ./.* 2>/dev/null || true
              fi
              
              # Clone repository with token if provided
              if [ -n "$GITHUB_TOKEN" ]; then
                git clone "$REPO_URL" . || {
                  echo "Git clone failed, trying with token authentication..."
                  REPO_URL_WITH_TOKEN=$(echo "$REPO_URL" | sed "s|https://|https://$GITHUB_TOKEN@|")
                  git clone "$REPO_URL_WITH_TOKEN" .
                }
              else
                git clone "$REPO_URL" .
              fi
            else
              # Update remote URL if needed
              CURRENT_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
              CLEAN_REPO_URL=$(echo "$REPO_URL" | sed 's|https://.*@||')
              
              if [ "$CURRENT_REMOTE" != "$CLEAN_REPO_URL" ] && [ "$CURRENT_REMOTE" != "$REPO_URL" ]; then
                echo "Updating git remote URL..."
                git remote set-url origin "$CLEAN_REPO_URL" 2>/dev/null || git remote add origin "$CLEAN_REPO_URL"
              fi
              
              echo "Pulling latest changes..."
              
              # Pull with token if needed
              if [ -n "$GITHUB_TOKEN" ]; then
                git pull origin main || {
                  echo "Git pull failed, trying with token authentication..."
                  git -c credential.helper='!f() { echo "username=$GITHUB_TOKEN"; echo "password=$GITHUB_TOKEN"; }; f' pull origin main || \
                  git pull https://$GITHUB_TOKEN@$(echo "$REPO_URL" | sed 's|https://||' | sed 's|.*@||') main
                }
              else
                git pull origin main
              fi
            fi
            
            # Install dependencies
            if [ -f "package.json" ]; then
              echo "Installing npm dependencies..."
              npm install
            else
              echo "No package.json found, skipping npm install"
            fi
            
            # Get PM2 process ID if process exists
            PM2_ID=""
            PM2_NAME=""
            
            if command -v pm2 &> /dev/null; then
              # Try to find existing PM2 process by name or ID
              PM2_LIST=$(pm2 jlist 2>/dev/null || echo "[]")
              
              if [ "$PM2_LIST" != "[]" ] && [ -n "$PM2_LIST" ]; then
                if command -v jq &> /dev/null; then
                  # Get the first online process ID
                  PM2_ID=$(echo "$PM2_LIST" | jq -r '.[] | select(.pm2_env.status == "online") | .pm_id' | head -n 1)
                  PM2_NAME=$(echo "$PM2_LIST" | jq -r '.[] | select(.pm2_env.status == "online") | .name' | head -n 1)
                else
                  # Fallback: get ID from pm2 list
                  PM2_ID=$(pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
                fi
              fi
            fi
            
            # Stop PM2 process if it exists
            if [ -n "$PM2_ID" ] && [ "$PM2_ID" != "null" ] && [ "$PM2_ID" != "" ]; then
              echo "Stopping PM2 process (ID: $PM2_ID)..."
              pm2 stop $PM2_ID || pm2 stop "$PM2_NAME" || pm2 stop all || true
            else
              echo "No existing PM2 process found, stopping all processes..."
              pm2 stop all || true
            fi
            
            # Start PM2 process
            echo "Starting PM2 process..."
            if [ -f "ecosystem.config.js" ]; then
              pm2 start ecosystem.config.js
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            elif [ -f "app.js" ]; then
              pm2 start app.js
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            else
              pm2 start npm -- start
              NEW_PM2_ID=$(pm2 jlist 2>/dev/null | jq -r '.[] | select(.name != null) | .pm_id' | head -n 1 || pm2 list | grep -E "^\| [0-9]+" | head -n 1 | awk '{print $2}' | tr -d '|' | xargs)
            fi
            
            # Wait for process to initialize
            sleep 2
            
            # Display PM2 status and process ID
            echo ""
            echo "PM2 Process Status:"
            pm2 status
            
            if [ -n "$NEW_PM2_ID" ] && [ "$NEW_PM2_ID" != "null" ] && [ "$NEW_PM2_ID" != "" ]; then
              echo ""
              echo "PM2 Process ID: $NEW_PM2_ID"
            fi
          ENDSSH
          
          echo "Deployment completed successfully"

      - name: Capture PM2 logs on failure
        if: failure()
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          echo "Capturing PM2 logs due to deployment failure..."
          
          ssh $SSH_HOST "cd '$DEPLOY_PATH' && bash -s" << 'ENDSSH'
            echo "=== PM2 Status ==="
            pm2 status || echo "PM2 status command failed"
            echo ""
            
            echo "=== PM2 Process List ==="
            pm2 jlist || echo "PM2 jlist command failed"
            echo ""
            
            echo "=== PM2 Logs (Last 200 lines) ==="
            pm2 logs --lines 200 --nostream || echo "PM2 logs command failed"
            
            # Capture individual process logs if available
            PM2_LIST=$(pm2 jlist 2>/dev/null || echo "[]")
            if [ "$PM2_LIST" != "[]" ] && [ -n "$PM2_LIST" ]; then
              if command -v jq &> /dev/null; then
                for id in $(echo "$PM2_LIST" | jq -r '.[] | .pm_id' 2>/dev/null); do
                  echo ""
                  echo "=== Logs for PM2 process ID: $id ==="
                  pm2 logs $id --lines 100 --nostream || echo "Could not retrieve logs for process $id"
                done
              fi
            fi
          ENDSSH

